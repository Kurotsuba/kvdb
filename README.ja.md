# kvdb - Kurotsuba's (Kantan) Vector Database

## エグゼクティブサマリー

kvdbは、**RAG(Retrieval-Augmented Generation)システムの基盤技術**であるベクトルデータベースを、ゼロから実装して学ぶための教育プロジェクトです。社内で計画されているRAGプロジェクトで使用される技術スタックを理解し、実務に必要な知識を習得することを目的としています。

**キーポイント**:
- ✅ RAGシステムで必須のベクトル検索技術を実装
- ✅ 本番環境(Qdrant、Milvusなど)で使われる仕組みを学習
- ✅ Rustによる高性能システム開発の経験

**現在のバージョン**: v1.0 - メモリ上で動作する基本版

---

## クイックリファレンス

### プロジェクト概要
| 項目 | 内容 |
|------|------|
| **目的** | 社内RAGプロジェクトに必要なベクトルDB技術の習得、Rustの練習 |
| **技術スタック** | Rust, Python(ベンチマーク) |
| **現状** | v1.0完成(基本機能実装済み、全テストパス) |
| **成果物** | 動作するベクトルDB、32個のテスト、ベンチマークツール |

### ビジネス価値
- ✅ **RAGシステムの核心技術**を実装レベルで理解
- ✅ **技術選定能力**の向上
- ✅ **チーム貢献**の準備

### 次のマイルストーン
1. **v1.1** : データ永続化 → 再起動後もデータ保持
2. **v2.0** : REST API化 → アプリケーションからの利用
3. **v3.0** : 性能最適化 → 本番環境レベルの速度

### 関連する社内プロジェクト
- **RAGシステム開発**: 本プロジェクトで学ぶベクトル検索が中核技術
- **AIアプリケーション**: 意味検索、推薦システムなどに応用可能

---

## このプロジェクトについて

### 背景と目的

社内のRAGプロジェクトでは、大量の文書データを検索可能にする必要があります。その中核技術がベクトルデータベースです。本プロジェクトでは、この技術を「ブラックボックス」として使うのではなく、内部の動作原理から理解することで、より効果的な設計・運用ができる知識基盤を構築します。

### RAGシステムにおけるベクトルデータベースの役割

**RAG(Retrieval-Augmented Generation)**とは、大規模言語モデル(LLM)に外部の知識データベースを組み合わせて、より正確で最新の情報を提供する技術です。

```
ユーザーの質問
    ↓
[1] 質問をベクトルに変換(Embedding)
    ↓
[2] ベクトルデータベースで類似文書を検索 ← このプロジェクトで学ぶ部分
    ↓
[3] 関連文書をLLMに渡して回答生成
    ↓
回答を返す
```

kvdbは、この[2]の検索エンジン部分を実装したものです。

## ベクトルデータベースとは?

**簡単に言うと**: 意味的に似ているデータを高速に探すための特別なデータベースです。

### ビジネスでの活用例

**RAGシステムでの利用**:
- 「契約書の中から、この質問に関連する条項を探す」
- 「過去の問い合わせから、類似の事例を検索する」
- 「製品マニュアルから、ユーザーの質問に最も関連する部分を抽出」

**その他のAIアプリケーション**:
- 「この画像に似ている商品画像を探す」(ECサイト)
- 「この文章に近い意味の文章を見つける」(検索エンジン)
- 「このユーザーの行動履歴に基づいてレコメンド」(推薦システム)

従来のキーワード検索と異なり、**「意味」の類似性**で検索できるのが特徴です。

## できること

### ✅ 実装済みの機能
- **データの保存**: ベクトル(数値の並び)をIDと一緒に保存
- **類似検索**: 保存したデータの中から似ているものを探す
- **データ管理**: 追加、取得、一覧表示、削除ができる
- **対話モード**: コマンドを打ち込んで操作できる

### 基本的な操作
- `insert` - ベクトルデータを追加する
- `search` - 似ているベクトルを探す
- `get` - IDを指定してベクトルを取得
- `list` - 保存されているデータを全て表示
- `count` - データの個数を確認
- `delete` - データを削除

## プログラムの構造

このプロジェクトは、将来的に機能を追加しやすいように設計されています:

```
src/
├── lib.rs       # 基本機能(VecDB)
├── vector.rs    # ベクトル計算(正規化、類似度計算)
├── db.rs        # データベースの本体
├── cli.rs       # コマンド入力の処理
└── main.rs      # プログラムの起動部分
```

### なぜこの構造?

**本番システムを見据えた設計**:
1. **今(v1.0)**: コマンドラインで使える基本版 - 核となるロジックの理解
2. **次(v1.1)**: ファイル永続化 - データの保存と読み込み
3. **次(v2.0)**: REST API化 - アプリケーションからの利用
4. **将来(v3.0+)**: 性能最適化とクラウドデプロイ - 本番運用レベルへ

このように**段階的に機能を追加**していくことで、各フェーズの技術的課題を明確に理解できます。これは実際のプロダクト開発と同じアプローチです。

### 社内プロジェクトへの応用

本プロジェクトで学んだ知識は、以下の形で社内のRAGプロジェクトに活かせます:


**システム設計時**:
- ベクトル次元数、インデックスタイプの選択根拠を理解できる
- 性能要件(レイテンシ、スループット)と実装方式の関係がわかる

**運用時**:
- パフォーマンス問題発生時に、原因の切り分けができる
- 適切なチューニング方法を判断できる

## インストールと実行

### 必要なもの
- Rust(プログラミング言語) 1.70以上
- Python 3.8以上(ベンチマーク用)

### ビルド(実行ファイルを作る)
```bash
# リポジトリを入手
git clone <your-repo-url>
cd kvdb

# 実行ファイルを作成
cargo build --release

# テストを実行
cargo test
```

## 使い方

### 対話モード(REPL)で使う

一度起動すると、続けて複数の命令を実行できます:

```bash
# プログラムを起動
./target/release/kvdb

# 以下、対話的に操作
kvdb> insert vec1 1.0 0.0 0.0
Inserted to database with id

kvdb> insert vec2 0.0 1.0 0.0
Inserted to database with id

kvdb> search 0.7 0.7 0.0 --k_top 2
Top 2 results:
1. ID: vec2, Score: 0.7071, Vector: [0.0, 1.0, 0.0]
2. ID: vec1, Score: 0.7071, Vector: [1.0, 0.0, 0.0]

kvdb> count
2

kvdb> exit
Goodbye!
```

**説明**:
- `insert vec1 1.0 0.0 0.0` - "vec1"という名前で3次元のベクトル[1.0, 0.0, 0.0]を保存
- `search 0.7 0.7 0.0 --k_top 2` - [0.7, 0.7, 0.0]に似ているベクトルを上位2つ探す
- `count` - 保存されているベクトルの個数を表示

### 一回だけ実行する方法 (*注: 現在はデータが保存されないため意味がありません*)

プログラムを起動→命令実行→終了を一度にやります:

```bash
# ベクトルを追加
./target/release/kvdb insert vec1 1.0 2.0 3.0

# 検索
./target/release/kvdb search 1.0 2.0 3.0 --k_top 5

# 取得
./target/release/kvdb get vec1

# 一覧表示
./target/release/kvdb list

# 削除
./target/release/kvdb delete vec1
```

### Rustのプログラムから使う

他のRustプログラムからライブラリとして使えます:

```rust
use kvdb::VecDB;

fn main() {
    let mut db = VecDB::new();

    // ベクトルを追加(自動的に正規化されます)
    db.insert("doc1".to_string(), vec![1.0, 0.0, 0.0]).unwrap();
    db.insert("doc2".to_string(), vec![0.0, 1.0, 0.0]).unwrap();
    db.insert("doc3".to_string(), vec![0.7, 0.7, 0.0]).unwrap();

    // 似ているベクトルを探す
    let results = db.search(vec![1.0, 1.0, 0.0], 2).unwrap();

    for (id, vector, score) in results {
        println!("{}: 類似度 = {:.4}", id, score);
    }
}
```

## 性能測定

プログラムの速さを測定できます:

```bash
# Pythonのライブラリをインストール
pip install numpy

# ベンチマークを実行(10万個のベクトル、786次元、100回検索)
python3 benchmark.py
```

出力例:
```
データベースサイズ: 100,000 ベクトル
ベクトル次元: 786

挿入性能:
  合計時間: 8.234 秒
  スループット: 12,144.23 挿入/秒
  平均挿入時間: 0.082 ミリ秒

検索性能 (100回のランダム検索):
  平均検索時間: 45.123 ミリ秒
  スループット: 22.16 検索/秒
```

## 実装状況と成果

### ✅ 完了している機能(v1.0)

1. **コア機能の実装**
   - L2正規化による自動ベクトル正規化
   - コサイン類似度検索(正規化ベクトルのドット積)
   - CRUD操作(挿入(更新)、検索、取得、削除、一覧)

2. **アーキテクチャ設計**
   - ライブラリファーストデザインの採用
   - フラット配列による効率的なメモリレイアウト
   - 将来のAPI化を見据えたモジュール分離



### パフォーマンス測定結果

10万ベクトル(786次元)でのベンチマーク:
```
挿入性能: 約12,000 inserts/秒
検索性能: 平均45ms/検索 (100回平均)
```

これは線形探索(全件スキャン)での結果です。

## 技術的な特徴と制約

### 現在の実装(v1.0)

**長所**:
- ✅ シンプルで理解しやすいコード
- ✅ 高速な挿入処理(O(d): dは次元数)
- ✅ 正確な検索結果(全件捜索のため精度100%)
- ✅ メモリ効率の良いフラット配列ストレージ

**制約事項**(今後の開発で改善予定):
- ⚠️ **永続化なし**: プログラム終了でデータ消失(v1.1で対応)
- ⚠️ **線形探索**: データ量に比例して検索が遅くなる(v3.0で対応)
- ⚠️ **単一スレッド**: 並行処理非対応(v2.0で対応)
- ⚠️ **非圧縮**: 全精度f32保存(v3.0で量子化対応)

## 今後の開発ロードマップ

### 🚧 実装予定の機能(本番環境に向けて)

**v1.1 - データの永続化(Persistence)**
- [ ] ファイル保存
- [ ] 起動時の自動ロード機能
- **習得スキル**: シリアライゼーション、ファイルI/O、データ整合性

**v2.0 - REST API化(Production-Ready Interface)**
- [ ] HTTPサーバー
- [ ] JSON形式でのリクエスト/レスポンス
- [ ] 並行リクエストのハンドリング
- [ ] OpenAPI仕様書の作成
- **習得スキル**: Web API設計、非同期処理、API文書化

**v3.0 - 性能最適化(Enterprise Scale)**
- [ ] HNSW(階層的ナビゲータブルスモールワールド)インデックス実装
- [ ] Product Quantization(積量子化)によるメモリ削減
- [ ] SIMD命令による計算高速化
- [ ] Rayonによる並列検索
- **習得スキル**: アルゴリズム最適化、メモリ管理、並列処理

## このプロジェクトで習得できるスキル

### 技術面

1. **AIアプリケーションの基盤技術**
   - ベクトル埋め込み(Embedding)の扱い方
   - コサイン類似度、ドット積などの類似度計算
   - RAGシステムにおける検索エンジンの役割

2. **データ構造とアルゴリズム**
   - メモリ効率の良いフラット配列ストレージ
   - キャッシュ局所性を意識したデータレイアウト

3. **システムプログラミング(Rust)**
   - 所有権システムによるメモリ安全性
   - ゼロコスト抽象化
   - パフォーマンスプロファイリングと最適化

4. **ソフトウェア設計**
   - ライブラリファーストアーキテクチャ
   - インターフェース分離(CLI)
   - 段階的な機能拡張の設計


### キャリア面

- **RAGプロジェクトへの貢献**: 技術的な議論に参加できる知識レベルの獲得
- **技術選定への参画**: ベクトルDBソリューションの評価基準を理解
- **トラブルシューティング**: 本番環境で問題が起きた際の原因究明能力

## プロジェクトの位置づけ

### 学習プロジェクトとしての価値

以下の学習目標を達成します:

1. **ベクトルデータベースの内部動作の理解**
   - アルゴリズムとデータ構造の実装経験
   - 性能特性とトレードオフの体感的理解

2. **Rustによるシステムプログラミングスキル**
   - 高性能・高信頼性システムの開発手法
   - メモリ安全性とゼロコスト抽象化


### 本番環境での利用について

**重要**: これは教育用の実装です。実際のプロダクション環境では、以下のような成熟したソリューションの採用を推奨します:

- **[Qdrant](https://qdrant.tech/)**: Rust製、高性能、フィルタリング機能充実
- **[Milvus](https://milvus.io/)**: エンタープライズ向け、スケーラビリティ重視
- **[Weaviate](https://weaviate.io/)**: GraphQLサポート、セマンティック検索特化

本プロジェクトの学習成果は、これらの製品の**適切な選定・設計・運用**に活かすことができます。

## 今後の展開

- v1.1(永続化)の実装完了
- v2.0(REST API)の実装完了
- v3.0(性能最適化)への挑戦

---

## ライセンス

MITライセンス - 学習や実験に自由に使えます。

---

## 補足: 用語解説

### ベクトルとは?
数値の並びのことです。例: [1.0, 2.0, 3.0]
- 画像、文章、音声などをAIで数値化したもの
- 似ているものは似た数値の並びになる

### 正規化とは?
ベクトルの長さを1に揃えることです。
- 比較しやすくするための前処理
- 大きさの違いに影響されず、方向だけで比較できる

### 類似度とは?
二つのベクトルがどれくらい似ているかを表す数値です。
- 1に近いほど似ている
- -1に近いほど似ていない

### メモリ上とは?
コンピューターのRAM(一時記憶)に保存すること。
- 速い
- 電源を切ると消える

---

## 参考資料

### ベクトルデータベース関連
- [Pinecone: What is a Vector Database?](https://www.pinecone.io/learn/vector-database/)
- [Qdrant Documentation](https://qdrant.tech/documentation/)

### Rustシステムプログラミング
- [The Rust Programming Language](https://doc.rust-lang.org/book/)

---

*Kantan (簡単) - シンプルな実装から、深い理解へ。* 🚀
*RAGシステムの基盤技術を、ゼロから学ぶプロジェクト*